[оглавление](../README.md)



## 7. Конструкции языка

## 7.1. Условный оператор if-else

![Рис. 2. Условный оператор if в PHP](https://media.proglib.io/posts/2021/02/07/87f5ded81ab06297b6858d29641bfeb2.jpg)

Рис. 2. Условный оператор if в PHP

Оператор `if` выполняет код, если выполняется условие. В противном случае выполняется код после else, который переводится, как «иначе», «в другом случае».

Синтаксис оператора if-else

```php
if (условие) выполнить_код else выполнить_другой_код
```

Напишем несколько условий с оператором `if` и `if-else`:

```php
<?php
if (2 < 5) {
    echo 'true';
}
// true

if (2 > 5) {
    echo 'true';
} else {
    echo 'false';
}
// false
```

для проверки дополнительных условий используется оператор `elseif`:

```php
<?php
$number = 15;

if ($number < 3) {
    echo 'Число меньше трех.';
} elseif ($number > 4 && $number < 10) {
    echo 'Число в промежутке от 4 до 10.';
} else {
    echo 'Число больше 10.';
}
// Число больше 10
```

**Здесь**:

`&&` – логический оператор `И`. В нашем условии проверяемое число должно быть больше четырех и меньше десяти.

| **Оператор** | **Значение**    | **Результат**                  |
| ------------ | --------------- | ------------------------------ |
| $n and $m    | И               | true, если и $n, и $m true     |
| $n or $m     | Или             | true, если или $n, или $m true |
| $n xor $m    | Исключающее Или | true, если $n, или $m true     |
| ! $n         | Отрицание       | true, если $n не true          |
| $n && $m     | И               | true, если и $n, и $m true     |
| $n \|\| $m   | Или             | true, если или $n, или $m true |

Таблица 3. Логические операторы



## 7.2. Тернарный оператор

Тернарный оператор сокращает запись проверяемого условия и имеет следующий синтаксис:

```php
условие ? выполнить_код_если_истинно : выполнить_код_если_ложно:
```

Проверим, переменная `n` больше `10` или нет. Если значение `n` больше `10`, уменьшим значение `n` на единицу ([декремент](https://ru.wikipedia.org/wiki/Инкремент)). В противном случае увеличим на единицу (инкремент).

```php
<?php
$n = 5;
$n > 10 ? $n-- : $n++;
echo $n; // 6
```



## 7.3. Переключатель switch

Переключатель `switch` проводит нестрогое сравнение `==` значений и передает управление соответствующему оператору `case`. Если значение не совпадает со значением из `case`, тогда выполняется переход к оператору `default`.

Синтаксис переключателя switch

```php
switch (переменная) {
    case 'значение1':
           код
        break;
    case 'значение2':
           код
        break;    
    default:
           код
        break;
} 
```

Напишем конструкцию из переключателя `switch` и двух операторов `case`:

```php
<?php
$n = 3;

switch ($n) {
    case 1:
        echo "Число равно двум.";
        break;
    case 2:
        echo "Число равно пяти.";
        break;
    default:
        echo "Значение по умолчанию.";
        break;
}
// Значение по умолчанию.
```



## 7.4. Цикл while

![Рис. 3. Цикл while в PHP](https://media.proglib.io/posts/2021/02/07/83408d8738e3f1f0f2961254d53efd22.jpg)

Рис. 3. Цикл while в PHP

Оператор `while` выполняет код до тех пор, пока значение условия не станет ложным.

Синтаксис цикла while

```php
while (условие) {
    // код
}
```

Выведем на экран пять раз слово `Hello`.

```php
<?php
$m = 0;

while ($m < 4) {
    $m++;
    echo "Hello\n";
}

/*
Hello
Hello
Hello
Hello
*/
```

**Расшифровка**:

`while` – обозначение цикла.

`$m = 0` – начальное значение переменной `m`.

`$m < 5` – условие, которое проверяется перед началом цикла.

`$m++` – инкрементирование, то есть увеличение переменной на единицу.

`echo "Hello\n"` – вывод на экран слово `Hello` каждый раз с новой строки `\n`.

Другой способ записи с помощью декремента в условии:

```php
<?php
$m = 4;

while ($m--) {
    echo "Hello\n";
}

/*
Hello
Hello
Hello
Hello
*/
```

**Здесь**:

`$m--` – декрементация, то есть уменьшение значения переменной на единицу. В это примере знак декремента `--` стоит после переменной, поэтому мы получим четыре итерации (от 4 до 0).

Если поставить оператор декремента перед переменной `--$m`, то мы получим три итерации (от 4 до 1):

```php
<?php
$m = 4;

while (--$m) {
    echo "Hello\n";
}

/*
Hello
Hello
Hello
*/
```



## 7.5. Цикл do..while

Цикл `do..while` выполняется минимум один раз, так как условие выполнения цикла проверяется в конце итерации, а не в начале как в цикле `while`.

Синтаксис цикла do..while

```php
do {
    // код
} while (условие);
```

Напишем цикл, выводящий на экран четыре раза слово `Hello`:

```php
<?php
$a = 0;
do {
    echo "Hello\n";
    $a++;
} while ($a < 4);

/*
Hello
Hello
Hello
Hello
*/
```



## 7.6. Цикл for

![Рис. 4. Цикл for в PHP](https://media.proglib.io/posts/2021/02/07/eef3123dbc73a62fa18d6cc1294eeb00.jpg)

Рис. 4. Цикл for в PHP

Когда нам известно количество итераций, вместо цикла `while` лучше использовать цикл `for`.

Синтаксис цикла for

```php
for (инициализация; условие_цикла; счетчик)
    тело_цикла
```

1. Инициализирующее выражение выполняется один раз в начале цикла.
2. Проверяется условие. Если оно истинно, то выполняется тело цикла. Если ложно, то выполнение цикла прерывается.
3. В конце каждой итерации изменяется счетчик (увеличивается или уменьшается).

Цикл выполняется, до тех пор, пока условие истинно, то есть значение `i` не станет равным 4:

```php
<?php
for ($i=0; $i <= 4; $i++) {
    echo $i;
}

// 01234   
```



## 7.7. Цикл foreach

Данный тип цикла предназначен специально для перебора всех элементов массива. Напоминаем, что `массив — это набор так называемых ключей, каждому из которых соответствует некоторое значение`. Выглядит цикл следующим образом: 

Синтаксис цикла foreach:

```php
foreach (массив as $ключ => $значение)
	команды; 
```

Здесь команды циклически выполняются для каждого элемента массива, при этом очередная пара `ключ=>значение` оказывается в переменных `$ключ и $значение`.

У цикла foreach имеется и другая форма записи, которую следует применять, когда нас не интересует значение ключа очередного элемента. Выглядит она так: 

```php
foreach ($массив as $значение) 
	команды; 
```

В этом случае доступно лишь значение очередного элемента массива, но не его ключ. Переберем все элементы массива и умножим каждый элемент на 3:

```php
<?php
$array = [1, 2, 3, 4];
foreach ($array as $number) {
    $number *= 3;
    echo $number;
}

// 36912
```

Цикл `foreach` в форме, рассмотренной выше, оперирует не исходным массивом, а его копией. Это означает, что любые изменения, которые вносятся в массив, не могут быть "видны" из тела цикла. Такое поведение позволяет, например, в качестве массива использовать не только переменную, но и результат работы какой-нибудь функции, возвращающей массив. (В последнем случае функция будет вызвана всего один раз — до начала цикла, а затем работа станет производиться с копией возвращенного значения.) Для того чтобы иметь возможность изменять массив изнутри тела цикла, в PHP можно использовать ссылочный синтаксис (использование знака амперсанд `&`): 

```php
foreaсh ($массив as $ключ => &$значение) { 
	// здесь можно изменять $значение, при этом изменяются элементы 
	// исходного массива $массив 
} 
```



### Источники

- https://www.php.net/
- https://proglib.io/



[оглавление](../README.md)