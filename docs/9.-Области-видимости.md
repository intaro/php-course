## 9. Области видимости

## 9.1. Локальные переменные

Аргументы функции, передаваемые по значению, а не по ссылке, воспринимаются как некие временные объекты, которые создаются в момент вызова и исчезают после окончания функции. Например:

``` php
<php
$a = 100; // глобальная переменная, равная 100

function test($a) { 
    echo $a; // выводим значение параметра $a 
    // Параметр $a не имеет к глобальной переменной $a никакого отношения! 
    $a++; // изменяется локальная копия значения, переданного в $a 
} 

test(1); // выводит 1 
echo $a; // выводит 100 - глобальная переменная $a не изменилась
```

В действительности такими же свойствами будут обладать не только аргументы, но и все другие переменные, инициализируемые или используемые внутри функции. Совокупность таких переменных называют контекстом функции (или областью видимости внутри функции)

```php
<?php 
## Локальные переменные
function silly()
{
    $i = mt_rand(); // записывает в $i случайное число
    echo "$i<br />"; // выводит его на экран
    // Эта $i не имеет к глобальной $i никакого отношения!
} 

// Выводит в цикле 10 случайных чисел
for ($i = 0; $i != 10; $i++) 
	silly();
```

Здесь переменная `$i` в функции будет не той переменной `$i`, которая используется в программе для организации цикла. Поэтому, собственно, цикл и проработает только 10 "витков", напечатав 10 случайных чисел (а не будет крутиться долго и упорно, пока "в рулетке" функции `mt_rand()` не выпадет 10).

Собственно говоря, это нас устраивает. Действительно, мало ли какие имена переменных использует функция для своих личных целей. Какое до этого дело программе (которая вообще может быть написана другим человеком)? Вот и получается, что каждая функция — изолированный блок кода, живущий и обменивающийся с "окружающим миром" через свои параметры и возвращаемое значение.



## 9.2. Глобальные переменные 

В PHP есть способ, посредством которого функции могут добраться и до любой глобальной переменной в программе (не считая, конечно, передачи параметра по ссылке). Для этого они должны проделать определенные действия, а именно: до первого использования в своем теле внешней переменной объявить ее "глобальной" при помощи инструкции global: 

```php
<php

global $variable; 
```

Пример, который показывает удобство использования глобальных переменных внутри функции:

```php
<?php 
## Глобальные переменные в функции
$monthes = [
    1 => "Январь",
    2 => "Февраль",
    // ...
    12 => "Декабрь"
];

// Возвращает название месяца по его номеру. Нумерация начинается с 1!
function getMonthName($n)
{
    global $monthes;
    return $monthes[$n];
} 

// Применение
echo getMonthName(2); // выводит "Февраль"
```

Массив `$monthes`, содержащий названия месяцев, довольно объемен. Поэтому описывать его прямо в функции было бы, мягко говоря, неудобно — он бы тогда создавался при каждом вызове функции. В то же время функция `getMonthName()` представляет собой неплохое средство для приведения номера месяца к его словесному эквиваленту (что может потребоваться во многих программах). Она имеет единственный и понятный параметр — это номер месяца. 

Необходимо отметить, что на практике лучше избегать использование глобальных переменных. Забегая вперед, перечислим некоторые причины:

- Глобальные переменные в большинстве случаев нарушают инкапсуляцию. К ним открыт неконтролируемый доступ отовсюду.

- В большом проекте при обилии глобальных переменных возникает путаница в именах. Глобальную переменную же видно отовсюду, надо, чтобы отовсюду было понятно, зачем она.

- Глобальные переменные ухудшают масштабируемость проекта.

- Глобальные переменные ухудшают читаемость кода (в каком-то конкретно взятом месте непонятно, нужна ли какая-то конкретная глобальная переменная, или нет).

- Глобальные переменные приводят к трудноуловимым ошибкам. Примеры: нежелательное изменение её значения в другом месте/другим потоком, ошибочное использование глобальной переменной для промежуточных вычислений из-за совпадения имен, возвращение функцией неправильного значения при тех же параметрах (оказывается, она зависима от глобальной переменной, а ее кто-то поменял).

- Глобальные переменные увеличивают число прямых и косвенных связей в системе, делая её поведение труднопредсказуемым, а её саму - сложной для понимания и развития.



## 9.3. Массив $GLOBALS 

В принципе, есть и второй способ добраться до глобальных переменных. Это использование встроенного в язык массива `$GLOBALS`. Последний представляет собой хэш, ключи которого есть имена глобальных переменных, а значения — их величины. Данный массив доступен из любого места в программе — в том числе и из тела функции, и его не нужно никак дополнительно объявлять. Итак, приведенный выше пример можно переписать более лаконично: 

```php
<php

// Возвращает название месяца по его номеру. Нумерация начинается с 1! 
function getMonthName($n) { 
    return $GLOBALS["monthes"][$n]; 
} 
```

Кстати, тут мы опять сталкиваемся с тем, что не только переменные, но даже и массивы могут иметь совершенно любую структуру, какой бы сложной она ни была. Например, предположим, что у нас в программе есть ассоциативный массив $A, элементы которого — двумерные массивы чисел. Тогда доступ к какой-нибудь ячейке этого массива с использованием $GLOBALS мог бы выглядеть так: 

```php
$GLOBALS['A']['First'][10][20];
```

То есть получился четырехмерный массив! 

Насчет `$GLOBALS` следует добавить еще несколько полезных сведений:

- Как уже было подмечено, этот массив изначально является глобальным для любой функции, а также для самой программы. Так, вполне допустимо его использовать не только в теле функции, но и в любом другом месте. 

- С массивом $GLOBALS допустимы не все операции, разрешенные с обычными массивами. А именно, мы не можем: 

  • присвоить этот массив какой-либо переменной целиком, используя оператор =; 

  • как следствие, передать его функции "по значению" — можно передавать только по ссылке. 

  Однако остальные операции допустимы. Мы можем при желании, например, по одному перебрать у него все элементы и, скажем, вывести их значения на экран (с помощью цикла foreach). 

- Добавление нового элемента в $GLOBALS равнозначно созданию новой глобальной переменной, а выполнение операции unset() для него равносильно уничтожению соответствующей переменной. 



### Источники

- PHP7. Дмитрий Котеров, Игорь Симдянов
- https://ru.stackoverflow.com/