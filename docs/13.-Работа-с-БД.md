## 13. Работа с БД. Библиотека PDO

## 13.1. Что такое базы данных (БД) и зачем они нужны

База данных (БД) — совокупность связанных между собой данных, сохраняемая в двумерных таблицах информационной системы. 

Система управления базами данных (СУБД) — комплекс программ, позволяющих создать базу данных (БД) и манипулировать данными (вставлять, обновлять, удалять и выбирать). Система обеспечивает безопасность, надёжность хранения и целостность данных, а также предоставляет средства для администрирования БД



## 13.2. MySQL

MySQL - реляционная, свободно распространяемая, имеющая возможность работать на серверах Linux, безопасная и производительная СУБД. Чаще всего, на большинстве сайтов и приложений, написанных на PHP, в качестве СУБД используется именно MySQL.

В PHP имеется поддержка работы с этой СУБД. В ядре встроено множество функций, позволяющих выполнять любые запросы, производить чтение и запись данных, обрабатывать ошибки. 

### Что такое mysqli?

mysqli (MySQL Improved) — это библиотека PHP, добавляющая в язык полную поддержку баз данных MySQL.

### Что такое PDO?

**PDO (PHP Data Objects)** — расширение PHP, которое обеспечивает абстракцию *доступа к данным*, это значит, что вне зависимости от того, какая конкретная база данных используется, вы можете пользоваться одними и теми же функциями для выполнения запросов и выборки данных. PDO *не* абстрагирует саму *базу данных*, это расширение не переписывает SQL-запросы и не эмулирует отсутствующий в СУБД функционал. 



## 13.3. Почему стоит использовать PDO

Встроенные функции для работы MySQL, которые есть в PHP, на сегодняшний день являются устаревшими, поэтому при работе с СУБД рекомендуется использовать библиотеки - `mysqli` или `PDO`. Вообще, библиотека `mysqli` является низкоуровневой библиотекой, и её не желательно использовать в коде напрямую. Так же, используя `mysqli` нужно помнить об обеспечении безопасности SQL запросов, в частности необходимо делать защиту от SQL - инъекций. В свою очередь, используя библиотеку PDO, разрабатывать такую защиту не требуется, так как PDO изначально имеет встроенные функции и методы обеспечения безопасности. (в частности, так называемые `подготовленные запросы`).



## 13.4. Процесс работы с БД

Обычно, взаимодействие приложения на PHP с СУБД выглядит следующим образом:

1. Устанавливается подключение к серверу СУБД, используя параметры подключения (адрес, логин, пароль)
2. Проверяется корректность подключения. СУБД доступна, адрес, логин и пароль верные, и т.д.
3. Формируется SQL запрос (например чтение данных из таблицы)
4. Проверяется успешность выполнения SQL запроса.
5. Производится получение результата выполнения SQL запроса в виде массива записей.
6. Полученные записи используются в PHP - сценарии (к примеру, отображение строк в html - таблице)



## 13.5 Соединение с базой данных

Далее, будем рассматривать примеры работы с БД, используя библиотеку `PDO`.

Что бы установить соединение с БД, необходимо создать новый экземпляр базового класса `PDO`. Для этой операции требуется знать как минимум 3 параметра:

- Адрес сервера
- Логин
- Пароль

При использовании процедуры установки MySQL по-умолчанию, адресом сервера будет являться `localhost`, логином — `root`. Пароль для подключения будет тот, который вы использовали в одном из шагов во время установки СУБД.

Если же используется пакет OpenServer, то адрес и логин будет такой же, как и в случае дефолтной установки MySQL (адрес `localhost`, логин — `root`). Паролем же будет пустая строка - `''`.

```php
// простое подключение к бд
$db = new PDO('mysql:host=localhost;dbname=pdo', 'root', 'password');
```

Если же во время подключения к БД возникла ошибка, PHP выдаст сообщение:

```html
Fatal error: Uncaught PDOException: ...
```

### Проверка соединения

После соединения с СУБД необходимо выполнить проверку, является ли подключение успешным. Неверные параметры подключения, какие-либо неполадки на сервере, неверная настройка - всё это может провоцировать отказ подключения к БД.
Такие ситуации должны обрабатываться в PHP сценарии, прежде чем выполнять дальнейшие действия.


```php
// подключение с обработкой ошибок
try {  
	$dbh = new PDO('mysql:host=localhost;dbname=pdo', 'root', 'password');
} catch (PDOException $e) {
	print "Has errors: " . $e->getMessage();  die();
}
```



## 13.6. Подготовленные и прямые запросы

В PDO есть возможно выполнять SQL запросы двумя способами:

- `Прямой`
- `Подготовленный`

### Прямые запросы

- `query()` - функция используется в запросах, не вносящих в БД (например `SELECT`). Функция возвращает объект класса  `PDOStatement`, с которого при помощи методов `fetch()` или `fetchAll` извлекается результат выполнения запроса
- `exec()` - функция используется в запросах, которые вносят изменения в БД - `INSERT, DELETE, UPDATE`. Результатом работы функции будет число обработанных запросом строк.

Прямые запросы лучше использовать только если в содержимом запроса отсутствуют переменные, а так же есть уверенность, что запрос является безопасным и правильно экранированным. 

```php
$stmt = $db->query("SELECT * FROM phones");
while ($row = $stmt->fetch()){  
    echo '<pre>';  print_r($row);
}
```

### Подготовленные запросы

Если в запросе участвуют переменные, то такой запрос необходимо выполнять через механизм `подготовленных запросов`. Выглядит это следующим образом: в обычный SQL запрос вместо переменной вставляется специальный маркер - placeholder. В PDO поддерживаются так называемые `позиционные псевдопеременные (?)`, в которых переменные подставляются по порядку, и `именованные псевдопеременные (:name)`, в которых переменные подставляются по имени.

Примеры:

```php
$sql = "SELECT phone FROM phones WHERE id = ?";
$sql = "SELECT phone FROM phones WHERE type = :type";
```

Для выполнения подготовленного запроса, вначале требуется его конфигурирование при помощи метода `prepare()`. Данный метод так же возвращает объект класса `PDO statement`, но еще не содержащий данные. Что бы получить данные, нужно выполнить данный запрос, предварительно передавая в него переменные. 

Передать переменные можно двумя способами: 

- выполнить метод `execute()`, передав в качестве параметра массив переменных

```php
$stmt = $pdo->prepare("SELECT `phone` FROM phones WHERE `id` = ?");
$stmt->execute([
    $id,
]); 
$stmt = $pdo->prepare("SELECT `phone` FROM phones WHERE `type` = :type");
$stmt->execute([
    'type' => $type,
]);
```

- вызвать специальный метод `bindParam()`, в который так же передать переменную в формате `ключ - значение`

```php
$stmt = $pdo->prepare("SELECT `phone` FROM phones WHERE `type` = :type");
$stmt->bindParam(':type', $type);
$stmt->execute(); 
```

После того, как в `execute()` (или `bindParams()`) переданы переменные, можно извлечь результаты запроса:

```php
$id = 1;
$stmt = $db->prepare("SELECT * FROM phones WHERE `type` = ?");
$stmt->execute([
    $type,
]);
$phone = $stmt->fetch(PDO::FETCH_LAZY);
echo '<pre>';
print_r($phone);
```

> **Важно!** Подготовленные запросы являются основной причиной, почему стоит использовать PDO. Эта конструкция является единственной, позволяющей безопасно выполнять SQL запросы, в которых содержатся переменные.



## 13.7. Получение данных. 

### Метод fetch()

Данный метод используется для последовательного чтения полученных из БД строк. Он является аналогом функции `mysq_fetch_array()` и подобных, но работает иначе: вместо различных функций, отличающихся режимами работы, в данном случае используется всегда одна функция `fetch()`, а поведение задается переданным в нее параметром. Подробнее о параметрах тут - https://www.php.net/manual/ru/pdostatement.fetch.php

В примере используется параметр `PDO::FETCH_LAZY`: создается новый объект со свойствами, соответствующими именам столбцов результирующего набора:

```php
$id = 1;
$stmt = $db->prepare("SELECT * FROM phones WHERE `id` = ?");
$stmt->execute([$id]);
while ($row = $stmt->fetch(PDO::FETCH_LAZY)) {
    echo 'Phone: '.$row->phone;
}
```

В режиме `PDO::FETCH_LAZY` нет перерасхода памяти, к колонкам таблиц можно обращаться через индекс, имя или свойство (ООП стиль ->). Однако данный режим нельзя использовать в `fetchAll()`

### Метод fetchColumn()

Если требуется получить значение одной колонки, в PDO есть специальная функция - `fetchColumn()`. Такой подход удобно использовать, когда требуется запросить только одно поле - сокращается количество кода.

```php
$id = 1;
$stmt = $db->prepare("SELECT `phone` FROM phones WHERE `id` = ?");
$stmt->execute([$id]);
$phone = $stmt->fetchColumn();
echo 'Phone: ' . $phone;
```

### Метод fetchAll()

Возвращает массив, содержащий все строки результирующего набора:

```php
$data = $db
    ->query("SELECT * FROM phones")
    ->fetchAll(PDO::FETCH_ASSOC);
foreach ($data as $k => $v){
    echo 'Phone: ' . $v['phone'] . '<br>';
}
```

### PDO и оператор LIKE

Используя подготовленные запросы, нужно помнить, что псевдопеременные запроса могут заменять **только** строку или число. Ни ключевое слово, ни идентификатор, ни часть строки или набор строк через псевдопеременные  **подставить нельзя**. Поэтому для `LIKE` необходимо сначала подготовить строку поиска целиком, а потом ее подставлять в запрос:

```php
$search = 'моб';
$query = "SELECT * FROM phones WHERE `type` LIKE ?";
$params = ["%$search%"];
$stmt = $db->prepare($query);
$stmt->execute($params);
$data = $stmt->fetchAll(PDO::FETCH_ASSOC);
$i = 1;
foreach ($data as $phone){
    echo $i++ . '. ' . $phone['phone'].'<br>';
}
```

В данном примере может быть проблема. Поиск может не работать, так как из БД приходят данные в неправильной кодировке. Необходимо добавить кодировку в подключение.

```php
$db = new PDO('mysql:host=localhost;dbname=pdo;charset=utf8mb4', 'root', '');
```

### PDO и оператор LIMIT

Если PDO работает в режиме эмуляции, все данные, которые были переданы напрямую в `execute()`, трансформируются как строки, тоесть обрамляются кавычками. Соответственно, `LIMIT ?,?` превращается в `LIMIT '10', '10'` и вызывает ошибку синтаксиса и, соответственно, пустой массив данных.

`Решение #1`: Отключить режим эмуляции:

```php
$db->setAttribute(PDO::ATTR_EMULATE_PREPARES, false);
```

`Решение #2`: Подставить значения `LIMIT` через `bindValue()`, принудительно выставляя им тип `PDO::PARAM_INT`:

```php
$limit = 3;
$stm = $db->prepare('SELECT * FROM phones LIMIT ?');
$stm->bindValue(1, $limit, PDO::PARAM_INT);
$stm->execute();
$data = $stm->fetchAll();
echo '<pre>';
print_r($data);
```

### PDO и оператор IN

```php
$arr = [1,3,6];
$in  = str_repeat('?,', count($arr) - 1) . '?';
$sql = "SELECT * FROM phones WHERE `id` IN ($in)";
$stm = $db->prepare($sql);
$stm->execute($arr);
$data = $stm->fetchAll();
echo '<pre>';
print_r($data);
```

### Добавление записей

```php
$phone = '+71234567890';
$query = "INSERT INTO `phones` (`phone`) VALUES (:phone)";
$params = [
    ':phone' => $phone
];
$stmt = $pdo->prepare($query);
$stmt->execute($params);
```

### Изменение записей

```php
$id = 1;
$phone = '+79999999999';
$query = "UPDATE `phones` SET `phone` = :phone WHERE `id` = :id";
$params = [
    ':id' => $id,
    ':phone' => $phone
];
$stmt = $pdo->prepare($query);
$stmt->execute($params);
```

### Удаление записей

```php
$id = 1;
$query = "DELETE FROM `phones` WHERE `id` = ?";
$params = [$id];
$stmt = $pdo->prepare($query);
$stmt->execute($params);
```

### Использование транзакций

Предположим, что мы создаём несколько записей для нового сотрудника с номером ID 23. Помимо ввода основной информации, необходимо записать его зарплату. Довольно просто сделать два отдельных обновления таблиц, однако путём заключения этих запросов в рамки [PDO::beginTransaction()](https://www.php.net/manual/ru/pdo.begintransaction.php) и [PDO::commit()](https://www.php.net/manual/ru/pdo.commit.php) мы сможем гарантировать, что никто не увидит этих изменений, пока все они не будут завершены. Если что-то пойдёт не так, catch-блок откатит все изменения с начала транзакции и напечатает сообщение об ошибке.

```php
try {
    // Начало транзакции  
    $pdo->beginTransaction();  
    // ... code  
    // Если в результате выполнения нашего кода всё прошло успешно,  
    // то зафиксируем этот результат  
    $pdo->commit();
} catch (Exception $e) {  
    // Иначе, откатим транзакцию.   
    $pdo->rollBack();  
    echo "Ошибка: " . $e->getMessage();
}
```

> **Важно!** Транзакции в PDO работают только с таблицами `InnoDB`



### Источники

- https://www.php.net/
- PHP7. Дмитрий Котеров, Игорь Симдянов